{"version":3,"file":"schema.js","sourceRoot":"/","sources":["database/schema.ts"],"names":[],"mappings":"AAEA,OAAO,EACN,WAAW,EACX,OAAO,EACP,iBAAiB,GACjB,MAAM,2BAA2B,CAAC;AAEnC,MAAM,UAAU,WAAW,CAAC,IAAoC;IAC/D,MAAM,mBAAmB,GAAQ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,qBAAqB,EAAE;QACxE,WAAW,EAAE,YAAY;KACzB,CAAC,CAAC;IACH;IACC,6BAA6B;IAC7B,gCAAgC;IAChC,gDAAgD;IAChD,mBAAmB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,EAC9B,CAAC;QACF,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,0BAA0B,EAAE;YAC5C,WAAW,EAAE,YAAY;SACzB,CAAC,CAAC;IACJ,CAAC;IAED,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;GAyBf,CAAC,CAAC;AACL,CAAC","sourcesContent":["import type { Generated, Insertable, Selectable, Updateable } from \"kysely\";\nimport type { SqliteWasmDatabase } from \"sqlite-wasm-kysely\";\nimport {\n\tDeclaration,\n\tPattern,\n\tVariableReference,\n} from \"../json-schema/pattern.js\";\n\nexport function applySchema(args: { sqlite: SqliteWasmDatabase }) {\n\tconst foreignKeyActivated: any = args.sqlite.exec(\"PRAGMA foreign_keys\", {\n\t\treturnValue: \"resultRows\",\n\t});\n\tif (\n\t\t// first row that is returned\n\t\t// first column of the first row\n\t\t// is equal to 0, then foreign keys are disabled\n\t\tforeignKeyActivated[0][0] === 0\n\t) {\n\t\targs.sqlite.exec(\"PRAGMA foreign_keys = ON\", {\n\t\t\treturnValue: \"resultRows\",\n\t\t});\n\t}\n\n\targs.sqlite.exec(`\nCREATE TABLE IF NOT EXISTS bundle (\n  id TEXT PRIMARY KEY DEFAULT (human_id()),\n\tdeclarations BLOB NOT NULL DEFAULT (jsonb('[]'))\n) strict;\n\nCREATE TABLE IF NOT EXISTS message (\n  id TEXT PRIMARY KEY DEFAULT (uuid_v7()), \n  bundle_id TEXT NOT NULL,\n  locale TEXT NOT NULL,\n  selectors BLOB NOT NULL DEFAULT (jsonb('[]')),\n  FOREIGN KEY (bundle_id) REFERENCES bundle(id) ON DELETE CASCADE\n) strict;\n\n\nCREATE TABLE IF NOT EXISTS variant (\n  id TEXT PRIMARY KEY DEFAULT (uuid_v7()), \n  message_id TEXT NOT NULL,\n  matches BLOB NOT NULL DEFAULT (jsonb('[]')),\n  pattern BLOB NOT NULL DEFAULT (jsonb('[]')),\n  FOREIGN KEY (message_id) REFERENCES message(id) ON DELETE CASCADE\n) strict;\n  \nCREATE INDEX IF NOT EXISTS idx_message_bundle_id ON message (bundle_id);\nCREATE INDEX IF NOT EXISTS idx_variant_message_id ON variant (message_id);\n\t\t`);\n}\n\nexport type InlangDatabaseSchema = {\n\tbundle: BundleTable;\n\tmessage: MessageTable;\n\tvariant: VariantTable;\n};\n\ntype BundleTable = {\n\tid: Generated<string>;\n\tdeclarations: Generated<Array<Declaration>>;\n};\n\ntype MessageTable = {\n\tid: Generated<string>;\n\tbundleId: string;\n\tlocale: string;\n\tselectors: Generated<Array<VariableReference>>;\n};\n\ntype VariantTable = {\n\tid: Generated<string>;\n\tmessageId: string;\n\tmatches: Generated<Array<Match>>;\n\tpattern: Generated<Pattern>;\n};\n\n/**\n * A match is a variable reference that is either a literal or a catch-all.\n *\n * https://github.com/opral/inlang-sdk/issues/205\n *\n * @example\n *   match = { type: \"match\", name: \"gender\", value: { type: \"literal\", value: \"male\"  }}\n */\nexport type Match = LiteralMatch | CatchAllMatch;\n\nexport type LiteralMatch = {\n\ttype: \"literal-match\";\n\tkey: VariableReference[\"name\"];\n\tvalue: string;\n};\nexport type CatchAllMatch = {\n\ttype: \"catchall-match\";\n\tkey: VariableReference[\"name\"];\n};\n\nexport type Bundle = Selectable<BundleTable>;\nexport type NewBundle = Insertable<BundleTable>;\nexport type BundleUpdate = Updateable<BundleTable>;\n\nexport type Message = Selectable<MessageTable>;\nexport type NewMessage = Insertable<MessageTable>;\nexport type MessageUpdate = Updateable<MessageTable>;\n\nexport type Variant = Selectable<VariantTable>;\nexport type NewVariant = Insertable<VariantTable>;\nexport type VariantUpdate = Updateable<VariantTable>;\n\nexport type MessageNested = Message & {\n\tvariants: Variant[];\n};\nexport type NewMessageNested = NewMessage & {\n\tvariants: NewVariant[];\n};\nexport type MessageNestedUpdate = Updateable<MessageTable> & {\n\tvariants: VariantUpdate[];\n};\n\nexport type BundleNested = Bundle & {\n\tmessages: MessageNested[];\n};\nexport type NewBundleNested = NewBundle & {\n\tmessages: NewMessageNested[];\n};\nexport type BundleNestedUpdate = BundleUpdate & {\n\tmessages: MessageNestedUpdate[];\n};\n"]}