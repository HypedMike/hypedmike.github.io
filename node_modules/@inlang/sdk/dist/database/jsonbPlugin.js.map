{"version":3,"file":"jsonbPlugin.js","sourceRoot":"/","sources":["database/jsonbPlugin.ts"],"names":[],"mappings":"AAAA,OAAO,EACN,wBAAwB,EACxB,GAAG,EACH,aAAa,EACb,SAAS,EACT,UAAU,EACV,sBAAsB,EAOtB,cAAc,GACd,MAAM,QAAQ,CAAC;AAGhB,MAAM,OAAO,WAAW;IACvB,yBAAyB,GAAG,IAAI,yBAAyB,EAAE,CAAC;IAC5D,gBAAgB,GAAG,IAAI,sBAAsB,EAAE,CAAC;IAChD,SAAS,CAAqB;IAE9B,YAAY,IAAsC;QACjD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC;IAChC,CAAC;IAED;;;;OAIG;IACH,cAAc,CAAC,IAA8B;QAC5C,IACC,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,iBAAiB;YACpC,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,iBAAiB,EACnC,CAAC;YACF,MAAM,MAAM,GAAG,IAAI,CAAC,yBAAyB,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACvE,OAAO,MAAM,CAAC;QACf,CAAC;QACD,OAAO,IAAI,CAAC,IAAI,CAAC;IAClB,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,eAAe,CACpB,IAA+B;QAE/B,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;YACpC,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;gBACvB,IACC,GAAG,CAAC,GAAG,CAAC,YAAY,WAAW;oBAC/B,kBAAkB;oBAClB,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAC3B,CAAC;oBACF,IAAI,CAAC;wBACJ,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,gBAAgB,EAAE;4BACjD,WAAW,EAAE,YAAY;4BACzB,IAAI,EAAE,CAAC,GAAG,CAAC,GAAG,CAAQ,CAAC;yBACvB,CAAC,CAAC;wBAEH,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAQ,CAAC,CAAC;oBACtC,CAAC;oBAAC,MAAM,CAAC;wBACR,yBAAyB;oBAC1B,CAAC;gBACF,CAAC;YACF,CAAC;QACF,CAAC;QACD,2EAA2E;QAC3E,OAAO,IAAI,CAAC,gBAAgB,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACpD,CAAC;CACD;AAED,MAAM,yBAA0B,SAAQ,wBAAwB;IAC5C,mBAAmB,CAAC,IAAoB;QAC1D,OAAO,KAAK,CAAC,mBAAmB,CAAC;YAChC,GAAG,IAAI;YACP,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;gBACzC,IAAI,UAAU,CAAC,IAAI,KAAK,kBAAkB,EAAE,CAAC;oBAC5C,OAAO,UAAU,CAAC;gBACnB,CAAC;gBACD,OAAO;oBACN,IAAI,EAAE,kBAAkB;oBACxB,MAAM,EAAE,UAAU,CAAC,MAAM;oBACzB,2DAA2D;oBAC3D,KAAK,EAAE,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,KAAK,CAAC;iBAC5C,CAAC;YACH,CAAC,CAAC;SACF,CAAC,CAAC;IACJ,CAAC;IAEkB,cAAc,CAAC,IAAe;QAChD,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;QACvB,MAAM,eAAe,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;QAClD,IAAI,KAAK,KAAK,eAAe,EAAE,CAAC;YAC/B,OAAO,IAAI,CAAC;QACb,CAAC;QACD,0DAA0D;QAC1D,OAAO,GAAG,CAAA,SAAS,eAAe,GAAG,CAAC,eAAe,EAAE,CAAC;IACzD,CAAC;IACD;;OAEG;IACgB,kBAAkB,CAAC,IAAmB;QACxD,OAAO,KAAK,CAAC,kBAAkB,CAAC;YAC/B,GAAG,IAAI;YACP,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,YAAY,EAAE,EAAE;gBACxC,IAAI,YAAY,CAAC,IAAI,KAAK,WAAW,EAAE,CAAC;oBACvC,OAAO,YAAY,CAAC;gBACrB,CAAC;gBACD,0DAA0D;gBAC1D,MAAM,EAAE,KAAK,EAAE,GAAG,YAAY,CAAC;gBAC/B,MAAM,eAAe,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;gBAElD,IAAI,KAAK,KAAK,eAAe,EAAE,CAAC;oBAC/B,OAAO,YAAY,CAAC;gBACrB,CAAC;gBACD,OAAO,GAAG,CAAA,SAAS,eAAe,GAAG,CAAC,eAAe,EAAE,CAAC;YACzD,CAAC,CAAC;SACF,CAAC,CAAC;IACJ,CAAC;IAED;;OAEG;IACM,eAAe,CAAC,IAAgB;QACxC,OAAO,KAAK,CAAC,eAAe,CAAC;YAC5B,GAAG,IAAI;YACP,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,aAAa,EAAE,EAAE;gBACzC,IAAI,aAAa,CAAC,IAAI,KAAK,wBAAwB,EAAE,CAAC;oBACrD,OAAO,aAAa,CAAC;gBACtB,CAAC;gBAED,oCAAoC;gBACpC,OAAO;oBACN,IAAI,EAAE,eAAe;oBACrB,MAAM,EAAE,aAAa,CAAC,MAAM,CAAC,GAAG,CAC/B,CAAC,KAAK,EAAE,EAAE,CACT,CAAC;wBACA,IAAI,EAAE,WAAW;wBACjB,KAAK;qBACL,CAAc,CAChB;iBACgB,CAAC;YACpB,CAAC,CAAC;SACF,CAAC,CAAC;IACJ,CAAC;CACD;AAED,SAAS,kBAAkB,CAAC,KAAU;IACrC;IACC,cAAc;IACd,KAAK,YAAY,WAAW;QAC5B,kBAAkB;QAClB,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC;QACzB,KAAK,KAAK,IAAI;QACd,KAAK,KAAK,SAAS,EAClB,CAAC;QACF,OAAO,KAAK,CAAC;IACd,CAAC;SAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QAC9D,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAC9B,CAAC;IACD,OAAO,KAAK,CAAC;AACd,CAAC;AAED,mGAAmG;AACnG,yGAAyG;AACzG,iEAAiE;AACjE,qBAAqB;AACrB,0BAA0B;AAC1B,4BAA4B;AAC5B,uBAAuB;AACvB,wEAAwE;AACxE,kCAAkC;AAClC,iBAAiB;AACjB,KAAK;AACL,4FAA4F;AAC5F,yEAAyE;AACzE,wCAAwC;AACxC,iBAAiB;AACjB,KAAK;AACL,iEAAiE;AACjE,oEAAoE;AACpE,kEAAkE;AAClE,2DAA2D;AAC3D,uDAAuD;AACvD,kCAAkC;AAClC,yDAAyD;AACzD,MAAM;AACN,KAAK;AACL,gDAAgD;AAChD,iEAAiE;AACjE,SAAS;AACT,mEAAmE;AACnE,2CAA2C;AAC3C,2DAA2D;AAC3D,6EAA6E;AAC7E,kEAAkE;AAClE,QAAQ;AACR,mDAAmD;AACnD,MAAM;AACN,4EAA4E;AAC5E,4EAA4E;AAC5E,iCAAiC;AACjC,0BAA0B;AAC1B,wDAAwD;AACxD,wDAAwD;AACxD,KAAK;AAEL,YAAY;AACZ,aAAa;AACb,YAAY;AACZ,MAAM;AACN,IAAI","sourcesContent":["import {\n\tOperationNodeTransformer,\n\tsql,\n\tValueListNode,\n\tValueNode,\n\tValuesNode,\n\tParseJSONResultsPlugin,\n\ttype KyselyPlugin,\n\ttype PluginTransformQueryArgs,\n\ttype PluginTransformResultArgs,\n\ttype QueryResult,\n\ttype RootOperationNode,\n\ttype UnknownRow,\n\tOnConflictNode,\n} from \"kysely\";\nimport type { SqliteWasmDatabase } from \"sqlite-wasm-kysely\";\n\nexport class JsonbPlugin implements KyselyPlugin {\n\t#serializeJsonTransformer = new SerializeJsonbTransformer();\n\t#parseJsonPlugin = new ParseJSONResultsPlugin();\n\t#database: SqliteWasmDatabase;\n\n\tconstructor(args: { database: SqliteWasmDatabase }) {\n\t\tthis.#database = args.database;\n\t}\n\n\t/**\n\t * For an outgoing query like insert or update, the JSON\n\t * values are transformed into `jsonb` function calls when\n\t * executed against the database.\n\t */\n\ttransformQuery(args: PluginTransformQueryArgs): RootOperationNode {\n\t\tif (\n\t\t\targs.node.kind === \"InsertQueryNode\" ||\n\t\t\targs.node.kind === \"UpdateQueryNode\"\n\t\t) {\n\t\t\tconst result = this.#serializeJsonTransformer.transformNode(args.node);\n\t\t\treturn result;\n\t\t}\n\t\treturn args.node;\n\t}\n\n\t/**\n\t * For incoming query results, the JSON binaries are parsed\n\t * into JSON objects.\n\t */\n\tasync transformResult(\n\t\targs: PluginTransformResultArgs\n\t): Promise<QueryResult<UnknownRow>> {\n\t\tfor (const row of args.result.rows) {\n\t\t\tfor (const key in row) {\n\t\t\t\tif (\n\t\t\t\t\trow[key] instanceof ArrayBuffer ||\n\t\t\t\t\t// uint8array, etc\n\t\t\t\t\tArrayBuffer.isView(row[key])\n\t\t\t\t) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst res = this.#database.exec(`SELECT json(?)`, {\n\t\t\t\t\t\t\treturnValue: \"resultRows\",\n\t\t\t\t\t\t\tbind: [row[key] as any],\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\trow[key] = JSON.parse(res[0] as any);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// it's not a json binary\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// in case it's a regular (text) json, run it through kyseley's json parser\n\t\treturn this.#parseJsonPlugin.transformResult(args);\n\t}\n}\n\nclass SerializeJsonbTransformer extends OperationNodeTransformer {\n\tprotected override transformOnConflict(node: OnConflictNode): OnConflictNode {\n\t\treturn super.transformOnConflict({\n\t\t\t...node,\n\t\t\tupdates: node.updates?.map((updateItem) => {\n\t\t\t\tif (updateItem.kind !== \"ColumnUpdateNode\") {\n\t\t\t\t\treturn updateItem;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tkind: \"ColumnUpdateNode\",\n\t\t\t\t\tcolumn: updateItem.column,\n\t\t\t\t\t// @ts-expect-error - we know that the value is a ValueNode\n\t\t\t\t\tvalue: this.transformValue(updateItem.value),\n\t\t\t\t};\n\t\t\t}),\n\t\t});\n\t}\n\n\tprotected override transformValue(node: ValueNode): ValueNode {\n\t\tconst { value } = node;\n\t\tconst serializedValue = maybeSerializeJson(value);\n\t\tif (value === serializedValue) {\n\t\t\treturn node;\n\t\t}\n\t\t// @ts-expect-error - we know that the node is a ValueNode\n\t\treturn sql`jsonb(${serializedValue})`.toOperationNode();\n\t}\n\t/**\n\t * Transforms the value list node by replacing all JSON objects with `jsonb` function calls.\n\t */\n\tprotected override transformValueList(node: ValueListNode): ValueListNode {\n\t\treturn super.transformValueList({\n\t\t\t...node,\n\t\t\tvalues: node.values.map((listNodeItem) => {\n\t\t\t\tif (listNodeItem.kind !== \"ValueNode\") {\n\t\t\t\t\treturn listNodeItem;\n\t\t\t\t}\n\t\t\t\t// @ts-expect-error - we know that the node is a ValueNode\n\t\t\t\tconst { value } = listNodeItem;\n\t\t\t\tconst serializedValue = maybeSerializeJson(value);\n\n\t\t\t\tif (value === serializedValue) {\n\t\t\t\t\treturn listNodeItem;\n\t\t\t\t}\n\t\t\t\treturn sql`jsonb(${serializedValue})`.toOperationNode();\n\t\t\t}),\n\t\t});\n\t}\n\n\t/**\n\t * Why this function is needed or why this works remains a mystery.\n\t */\n\toverride transformValues(node: ValuesNode): ValuesNode {\n\t\treturn super.transformValues({\n\t\t\t...node,\n\t\t\tvalues: node.values.map((valueItemNode) => {\n\t\t\t\tif (valueItemNode.kind !== \"PrimitiveValueListNode\") {\n\t\t\t\t\treturn valueItemNode;\n\t\t\t\t}\n\n\t\t\t\t// change valueItem to ValueListNode\n\t\t\t\treturn {\n\t\t\t\t\tkind: \"ValueListNode\",\n\t\t\t\t\tvalues: valueItemNode.values.map(\n\t\t\t\t\t\t(value) =>\n\t\t\t\t\t\t\t({\n\t\t\t\t\t\t\t\tkind: \"ValueNode\",\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t}) as ValueNode\n\t\t\t\t\t),\n\t\t\t\t} as ValueListNode;\n\t\t\t}),\n\t\t});\n\t}\n}\n\nfunction maybeSerializeJson(value: any): any {\n\tif (\n\t\t// binary data\n\t\tvalue instanceof ArrayBuffer ||\n\t\t// uint8array, etc\n\t\tArrayBuffer.isView(value) ||\n\t\tvalue === null ||\n\t\tvalue === undefined\n\t) {\n\t\treturn value;\n\t} else if (typeof value === \"object\" || Array.isArray(value)) {\n\t\treturn JSON.stringify(value);\n\t}\n\treturn value;\n}\n\n// The code here didn't work https://github.com/opral/inlang-sdk/issues/132#issuecomment-2339321910\n// but would be the \"right\" solution to avoid heuristics which column might or might not be a json column\n// // modifies the query in place for readability and performance\n// function mapQuery(\n// \tnode: InsertQueryNode,\n// \tjsonColumns: TableSchema\n// ): InsertQueryNode {\n// \t// if the query is not an insert query, we don't need to do anything\n// \tif (node.into === undefined) {\n// \t\treturn node;\n// \t}\n// \t// if the table is not in the schema that has json columns, we don't need to do anything\n// \tconst columnsWithJson = jsonColumns[node.into.table.identifier.name];\n// \tif (columnsWithJson === undefined) {\n// \t\treturn node;\n// \t}\n// \t// find the indexes of the values that need to be transformed\n// \t// SQL query: INSERT INTO table (col1, col2) VALUES (val1, val2)\n// \tconst indexesThatNeedToBeTransformed: [number, string][] = [];\n// \tfor (const [i, col] of node.columns?.entries() ?? []) {\n// \t\tconst jsonType = columnsWithJson[col.column.name];\n// \t\tif (jsonType !== undefined) {\n// \t\t\tindexesThatNeedToBeTransformed.push([i, jsonType]);\n// \t\t}\n// \t}\n// \tconst values = structuredClone(node.values);\n// \tfor (const [i, jsonType] of indexesThatNeedToBeTransformed) {\n// \t\tif (\n// \t\t\t// top level values node that should contain a list of values\n// \t\t\tnode.values?.kind !== \"ValuesNode\" &&\n// \t\t\t// the node we are interested in must be a value node\n// \t\t\t// @ts-expect-error - we know that the node is a ValuesNode with values\n// \t\t\t(node.values as ValuesNode).values?.[i].kind !== \"ValueNode\"\n// \t\t) {\n// \t\t\tthrow new Error(\"Unexpected node structure\");\n// \t\t}\n// \t\tconst serializedJson = JSON.stringify(node.values.values[0].values[i]);\n// \t\t// @ts-expect-error - we know that the node is a ValuesNode with values\n// \t\tvalues.values[0].values[i] =\n// \t\t\tjsonType === \"jsonb\"\n// \t\t\t\t? sql`jsonb(${serializedJson})`.toOperationNode()\n// \t\t\t\t: sql`json(${serializedJson})`.toOperationNode();\n// \t}\n\n// \treturn {\n// \t\t...node,\n// \t\tvalues,\n// \t};\n// }\n"]}