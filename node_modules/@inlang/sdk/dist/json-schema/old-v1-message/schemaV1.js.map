{"version":3,"file":"schemaV1.js","sourceRoot":"/","sources":["json-schema/old-v1-message/schemaV1.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAe,MAAM,mBAAmB,CAAC;AAMtD,MAAM,CAAC,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;IACjC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;IAC1B,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE;CACpB,CAAC,CAAC;AAGH,MAAM,CAAC,MAAM,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC;IAC9C,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC;IACvC,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE;CACnB,CAAC,CAAC;AASH,MAAM,CAAC,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;AAc9D,MAAM,CAAC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC;AAMxE,MAAM,CAAC,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC;IACpC,WAAW,EAAE,IAAI,CAAC,MAAM,EAAE;IAC1B;;;;OAIG;IACH,yFAAyF;IACzF,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;IAChC,OAAO,EAAE,SAAS;CAClB,CAAC,CAAC;AAGH,MAAM,CAAC,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC;IACpC,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE;IACjB,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC;IAChD;;OAEG;IACH,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC;IACnC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC;CAC/B,CAAC,CAAC","sourcesContent":["import { Type, type Static } from \"@sinclair/typebox\";\n\n/**\n * A (text) element that is translatable and rendered to the UI.\n */\nexport type TextV1 = Static<typeof TextV1>;\nexport const TextV1 = Type.Object({\n\ttype: Type.Literal(\"Text\"),\n\tvalue: Type.String(),\n});\n\nexport type VariableReferenceV1 = Static<typeof VariableReferenceV1>;\nexport const VariableReferenceV1 = Type.Object({\n\ttype: Type.Literal(\"VariableReference\"),\n\tname: Type.String(),\n});\n\n/**\n * An expression is a reference to a variable or a function.\n *\n * Think of expressions as elements that are rendered to a\n * text value during runtime.\n */\nexport type ExpressionV1 = Static<typeof ExpressionV1>;\nexport const ExpressionV1 = Type.Union([VariableReferenceV1]);\n\n// export type FunctionReference = {\n// \ttype: \"function\"\n// \tname: string\n// \toperand?: Text | VariableReference\n// \toptions?: Option[]\n// }\n\n/**\n * A pattern is a sequence of elements that comprise\n * a message that is rendered to the UI.\n */\nexport type PatternV1 = Static<typeof PatternV1>;\nexport const PatternV1 = Type.Array(Type.Union([TextV1, ExpressionV1]));\n\n/**\n * A variant contains a pattern that is rendered to the UI.\n */\nexport type VariantV1 = Static<typeof VariantV1>;\nexport const VariantV1 = Type.Object({\n\tlanguageTag: Type.String(),\n\t/**\n\t * The number of keys in each variant match MUST equal the number of expressions in the selectors.\n\t *\n\t * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection\n\t */\n\t// a match can always only be string-based because a string is what is rendered to the UI\n\tmatch: Type.Array(Type.String()),\n\tpattern: PatternV1,\n});\n\nexport type MessageV1 = Static<typeof MessageV1>;\nexport const MessageV1 = Type.Object({\n\tid: Type.String(),\n\talias: Type.Record(Type.String(), Type.String()),\n\t/**\n\t * The order in which the selectors are placed determines the precedence of patterns.\n\t */\n\tselectors: Type.Array(ExpressionV1),\n\tvariants: Type.Array(VariantV1),\n});\n"]}