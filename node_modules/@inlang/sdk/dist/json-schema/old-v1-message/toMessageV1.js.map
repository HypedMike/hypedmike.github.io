{"version":3,"file":"toMessageV1.js","sourceRoot":"/","sources":["json-schema/old-v1-message/toMessageV1.ts"],"names":[],"mappings":"AASA;;;;GAIG;AACH,MAAM,UAAU,WAAW,CAAC,MAAoB;IAC/C,MAAM,QAAQ,GAAgB,EAAE,CAAC;IACjC,MAAM,aAAa,GAAG,IAAI,GAAG,EAAU,CAAC;IAExC,KAAK,MAAM,OAAO,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;QACvC,6BAA6B;QAC7B,KAAK,MAAM,QAAQ,IAAI,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YACpD,IAAI,EAAE,oBAAoB;YAC1B,IAAI,EAAE,CAAC,CAAC,IAAI;SACZ,CAAC,CAAC,EAAE,CAAC;YACL,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAClC,CAAC;QAED,uBAAuB;QACvB,KAAK,MAAM,OAAO,IAAI,OAAO,CAAC,QAAQ,EAAE,CAAC;YACxC,QAAQ,CAAC,IAAI,CAAC;gBACb,WAAW,EAAE,OAAO,CAAC,MAAM;gBAC3B,KAAK,EAAE,EAAE;gBACT,OAAO,EAAE,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC;aACrC,CAAC,CAAC;QACJ,CAAC;IACF,CAAC;IAED,MAAM,SAAS,GAAmB,CAAC,GAAG,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QACnE,IAAI,EAAE,mBAAmB;QACzB,IAAI;KACJ,CAAC,CAAC,CAAC;IAEJ,OAAO;QACN,EAAE,EAAE,MAAM,CAAC,EAAE;QACb,KAAK,EAAE,EAAE;QACT,QAAQ;QACR,SAAS;KACT,CAAC;AACH,CAAC;AAED;;GAEG;AACH,SAAS,WAAW,CAAC,OAAgB;IACpC,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE;QAC9B,QAAQ,OAAO,CAAC,IAAI,EAAE,CAAC;YACtB,KAAK,MAAM,CAAC,CAAC,CAAC;gBACb,OAAO;oBACN,IAAI,EAAE,MAAM;oBACZ,KAAK,EAAE,OAAO,CAAC,KAAK;iBACpB,CAAC;YACH,CAAC;YAED,KAAK,YAAY,CAAC,CAAC,CAAC;gBACnB,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,oBAAoB,EAAE,CAAC;oBAC/C,OAAO;wBACN,IAAI,EAAE,mBAAmB;wBACzB,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC,IAAI;qBACtB,CAAC;gBACH,CAAC;gBACD,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;YACzD,CAAC;YAED,OAAO,CAAC,CAAC,CAAC;gBACT,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;YACrD,CAAC;QACF,CAAC;IACF,CAAC,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import type { BundleNested } from \"../../database/schema.js\";\nimport type { Pattern } from \"../pattern.js\";\nimport type {\n\tExpressionV1,\n\tMessageV1,\n\tPatternV1,\n\tVariantV1,\n} from \"./schemaV1.js\";\n\n/**\n * Converts a BundleNested into a legacy format.\n *\n * @throws If the message cannot be represented in the v1 format\n */\nexport function toMessageV1(bundle: BundleNested): MessageV1 {\n\tconst variants: VariantV1[] = [];\n\tconst selectorNames = new Set<string>();\n\n\tfor (const message of bundle.messages) {\n\t\t// collect all selector names\n\t\tfor (const selector of message.selectors.map((s) => ({\n\t\t\ttype: \"variable-reference\",\n\t\t\tname: s.name,\n\t\t}))) {\n\t\t\tselectorNames.add(selector.name);\n\t\t}\n\n\t\t// collect all variants\n\t\tfor (const variant of message.variants) {\n\t\t\tvariants.push({\n\t\t\t\tlanguageTag: message.locale,\n\t\t\t\tmatch: [],\n\t\t\t\tpattern: toV1Pattern(variant.pattern),\n\t\t\t});\n\t\t}\n\t}\n\n\tconst selectors: ExpressionV1[] = [...selectorNames].map((name) => ({\n\t\ttype: \"VariableReference\",\n\t\tname,\n\t}));\n\n\treturn {\n\t\tid: bundle.id,\n\t\talias: {},\n\t\tvariants,\n\t\tselectors,\n\t};\n}\n\n/**\n * @throws If the pattern cannot be represented in the v1 format\n */\nfunction toV1Pattern(pattern: Pattern): PatternV1 {\n\treturn pattern.map((element) => {\n\t\tswitch (element.type) {\n\t\t\tcase \"text\": {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"Text\",\n\t\t\t\t\tvalue: element.value,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcase \"expression\": {\n\t\t\t\tif (element.arg.type === \"variable-reference\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"VariableReference\",\n\t\t\t\t\t\tname: element.arg.name,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthrow new Error(`Unsupported expression argument type`);\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tthrow new Error(`Unsupported pattern element type`);\n\t\t\t}\n\t\t}\n\t});\n}\n"]}