{"version":3,"file":"detectJsonFormatting.js","sourceRoot":"/","sources":["utilities/detectJsonFormatting.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Detects the formatting of a JSON file and returns a function\n * that can be used to stringify JSON with the same formatting.\n *\n * @example\n *   const file = await fs.readFile(\"./messages.json\", { encoding: \"utf-8\" })\n *   const stringify = detectJsonFormatting(file)\n *   const newFile = stringify(json)\n */\nexport const detectJsonFormatting = (\n\tfile: string\n): ((\n\tvalue: Parameters<typeof JSON.stringify>[0],\n\treplacer?: Parameters<typeof JSON.stringify>[1]\n\t// space is provided by the function\n) => string) => {\n\tconst endsWithNewLine = file.endsWith(\"\\n\");\n\tconst spacing = guessJsonIndent(file);\n\n\treturn (value, replacer) =>\n\t\tJSON.stringify(value, replacer, spacing as any) +\n\t\t(endsWithNewLine ? \"\\n\" : \"\");\n};\n\n/**\n * vendored from https://github.com/ehmicky/guess-json-indent\n */\n// Guess the indentation of a JSON string\nconst guessJsonIndent = (jsonString: string) => {\n\tconst firstIndex = skipWhitespaces(jsonString, 0);\n\n\tif (\n\t\tfirstIndex === undefined ||\n\t\t!isJsonObjectOrArray(jsonString[firstIndex])\n\t) {\n\t\treturn;\n\t}\n\n\tconst secondIndex = skipWhitespaces(jsonString, firstIndex + 1);\n\n\tif (secondIndex === undefined) {\n\t\treturn;\n\t}\n\n\treturn getIndent(jsonString, firstIndex, secondIndex);\n};\n\n// Whitespaces are ignored before|between|after tokens in JSON.\n// Uses imperative logic for performance.\nconst skipWhitespaces = (jsonString: string | any[], startIndex: number) => {\n\tfor (let index = startIndex; index < jsonString.length; index += 1) {\n\t\tconst character = jsonString[index];\n\n\t\tif (!isJsonWhitespace(character)) {\n\t\t\treturn index;\n\t\t}\n\t}\n\treturn;\n};\n\n// JSON defines only those are valid whitespaces\nconst isJsonWhitespace = (character: string) =>\n\tcharacter === \" \" ||\n\tcharacter === \"\\t\" ||\n\tcharacter === \"\\n\" ||\n\tcharacter === \"\\r\";\n\n// If the top-level value is another type than an object or an array, there is\n// no possible indentation\nconst isJsonObjectOrArray = (character: string | undefined) =>\n\tcharacter === \"{\" || character === \"[\";\n\n// Uses imperative logic for performance\n// @ts-expect-error - not all code paths return a value\nconst getIndent = (\n\tjsonString: string | any[],\n\tfirstIndex: number,\n\tsecondIndex: number\n) => {\n\tlet indent;\n\n\tfor (let index = secondIndex - 1; index > firstIndex; index -= 1) {\n\t\tconst character = jsonString[index];\n\n\t\tif (character === \"\\r\") {\n\t\t\treturn;\n\t\t}\n\n\t\tif (character === \"\\n\") {\n\t\t\treturn normalizeIndent(indent);\n\t\t}\n\n\t\tif (indent === undefined) {\n\t\t\tindent = character;\n\t\t} else if (indent[0] === character) {\n\t\t\tindent += character;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n};\n\nconst normalizeIndent = (indent: string | any[] | undefined) => {\n\tif (indent === undefined) {\n\t\treturn 0;\n\t}\n\n\treturn indent[0] === \" \" ? indent.length : indent;\n};\n"]}